#+TITLE: Notes about Ardupilot & development
#+AUTHOR: HGM
#+DATE: Started 2026-01-13

(I had a previous file that I accidentally lost. It had scratch about waf, the build system, etc.)

* [[https://github.com/ArduPilot/ardupilot/issues/29566][Issue 29566: DO_SET_ROI_LOCATION (195) and DO_SET_ROI_NONE (197) "gimbal device id" fields should be supported]]
Working on it. Starting with the work by ahmedmsalah99. PR 30678.
Ok, I don't like that solution. Going my own way.

** Questions for reviewers:
In AP_Mount::handle_command_do_mount_configure, should we base the returned value on the true/false of the sub-call?

** I found a bug.
device_id == 0 is "all mounts" per MAVLINK, but _primary instance per AP_Mount.
I posted on the forum about them 2026-01-15.
Answer confirmed, so I created issue 31940 (for myself) to fix in the future.
Because RMackay said "consume gimbal id like manage pitchyaw (1000 or 287) handler", I'll lean into that to move forward.
(Worst case, they'll all be wrong the same way, and we can refactor to the right one.)
*** Gimbal device ID in mavlink: Different interpretations?
**** Gimbal info (280), Gimbal manager status (281)
Gimbal device ID that this gimbal manager is responsible for.
Component ID of gimbal device (or 1-6 for non-MAVLink gimbal).
Messages with same value are from the same source (instance).
**** 282, 287, 288, 195, 196, 197, 198, 1000, 1001
Component ID of gimbal device to address (or 1-6 for non-MAVLink gimbal), 0 for all gimbal device components.
Send command multiple times for more than one gimbal (but not all gimbals).
***** Looks like a copy-paste mistake:
Some have this additional stipulation (282, 287, 288):
"Messages with same value are from the same source (instance)."
Fairly harmless. I'm looking into how to flag/change it.
I reported it to the MAVLINK google group 2026-01-16.
**** Gimbal device info (283), Gimbal device attitude status (285)
This field is to be used if the gimbal manager and the gimbal device are the same component and hence have the same component ID.
This field is then set to a number between 1-6.
If the component ID is separate, this field is not required and must be set to 0.
**** 284, 286: interestingly, does NOT have device id in it
**** Camera info (259):
Gimbal id of a gimbal associated with this camera.
This is the component id of the gimbal device, or 1-6 for non mavlink gimbals.
Use 0 if no gimbal is associated with the camera.
** How does manage pitchyaw handler (287 or 1001?) do it?
packet.z = "instance". (Only comment suggests otherwise...)
instance=0 => primary. otherwise select (instance-1). (But when _primary==0, this is odd to me.)
Tracing back EXACTLY what packet.z actually is...
+ Comes in via AP_Mount::handle_command, packet.command==MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW
+ Called by GCS_MAVLINK::handle_command_mount, receives packet and msg
+ (Aside: I think copter calls into this chain somewhere?)
+ Called by GCS_MAVLINK::handle_command_int_packet (same args)
+ Lots of callers to this... but I think I'm getting where I want at this point. Let's break open packet and msg
*** mavlink_command_int_t &packet
7 params (p1-4, x-z)
uint16_t command
uint8_t target_system (system ID)
uint8_t target_component (component ID)
uint8_t frame (coordinate sys)
uint8_t current (UNUSED)
uint8_t autocontinue (UNUSED)
*** mavlink_message_t &msg
checksum
magic marker
len of payload
incompat_flags
compat_flags
seq (sequence)
sysid (id of message sender system...)
compid (id of the message sender component...)
msgid (id of message in payload)
payload ((the actual data))
ck (checksum)
signature
**** Q: Why would you want this msg available?
A: Evidently at least one backend wants to know who is sending the command and who is the (intended) receiver.
** Commands I'm concerned with
MAV_CMD_DO_GIMBAL_MANAGER_PITCHYAW=1000 comes through AP_Mount::handle_command... which is same, right?
#define MAVLINK_MSG_ID_GIMBAL_MANAGER_SET_PITCHYAW 287 comes in via GCS_MAVLINK::handle_message
*** 1 Do Set ROI Location (195) (= "set roi target")
*** 2 Do Set ROI None (197) (= "clear")
*** 3 Manage Pitchyaw (287. I don't think 1000 supported for copter) (already done, told to follow this pattern)
*** 4 Manager Configure (1001) (already done, has same pattern as manage pitchyaw)
*** 5 Mount configure? (204) (in AP_Mount::handle_command)
*** 6 Mount control? (205) (in AP_Mount::handle_command)
*** 7 Set ROI sysid? (198) (in AP_Mount::handle_command)
** Should new commands to set the target (195) and clear it (197): Should they come via handle_command?
*** Where does copter call into handle_command chain, and how is this different than where it calls into ROI target (195) & clear (197)?
Has GCS_MAVLink_Copter to override & call into general GCS_MAVLink handle_command_mount.
handle_command_mount called for 3--7 via a switch with aligned cases: handle_command_int_packet (handle command int).
Q: Do 1 & 2 have int packets?
why not for 1 & 2?
** Ideas for improvement
move handle_command_do_gimbal_manager_pitchyaw() logic into backend, have mount merely dispatch to backend(s).
fix bug regarding device_id==0
clarify naming: 'backends' vs 'gimbals' vs 'mounts' vs 'instances', and index'vs 'object'
why do both handle_message and handle_command exist?
** Fix in Copter
Overrides GCS_MAVLINK with specific, routes via auto_yaw.set_roi
** Fix in Plane
** Fix in Sub
Overrides with sub.mode_auto.set_auto_yaw_roi
** Don't fix in Blimp
(Blimp overrides with a no-op. Why is this commented? Shouldn't I update it?)
** Fix in Rover
** Fix in Lua scripting?
* Issue 26892: AP_Mount: mount_open servo output should work for all backends
Because AP_Param only supports 64 params per object, we need to represent "all params of all SRV channels" via more than one object.
Thus SRV_Channels contains an array of SRV_Channel objects.
It is named "obj_channels". Or maybe "channels"? (a pointer to it?) (Looks like both work, point to same thing.)
It has 32 members.

A "Function" is fundamentally an enum. Conceptually its a thing that an RC channel can do.

Oh, I think this was already done! Have posted in the github issue.
